use std::env;
use std::path::PathBuf;

use fs_err as fs;
use miette::{Context, IntoDiagnostic};
use prost::Message;

const MNT_PROTO: &str = "miden_note_transport.proto";
const MNT_DESCRIPTOR: &str = "miden_note_transport_file_descriptor.bin";

/// Generates Rust protobuf bindings from .proto files.
///
/// This is done only if `BUILD_PROTO` environment variable is set to `1` to avoid running the
/// script on crates.io where repo-level .proto files are not available.
fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo::rerun-if-changed=../../proto/proto");
    println!("cargo::rerun-if-env-changed=BUILD_PROTO");

    let out =
        env::var("OUT_DIR").expect("env::OUT_DIR is always set in build.rs when used with cargo");

    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let workspace_root = manifest_dir.parent().unwrap().parent().unwrap();
    let proto_dir = workspace_root.join("proto").join("proto");
    let includes = &[proto_dir];

    let mnt_file_descriptor = protox::compile([MNT_PROTO], includes)?;
    let mnt_path = PathBuf::from(&out).join(MNT_DESCRIPTOR);
    fs::write(&mnt_path, mnt_file_descriptor.encode_to_vec())
        .into_diagnostic()
        .wrap_err("writing mnt file descriptor")?;

    // Generate the Rust bindings
    let descriptor = mnt_file_descriptor;

    tonic_build::configure()
        .out_dir("src/generated")
        .build_server(true)
        .build_client(true)
        .compile_fds_with_config(prost_build::Config::new(), descriptor)
        .into_diagnostic()
        .wrap_err("generating protobuf bindings")?;

    // Generate mod.rs with clippy allows
    generate_mod_rs("src/generated")?;

    Ok(())
}

/// Generate `mod.rs` which includes all files in the folder as submodules.
fn generate_mod_rs(directory: impl AsRef<std::path::Path>) -> std::io::Result<()> {
    let mod_filepath = directory.as_ref().join("mod.rs");

    // Discover all submodules by iterating over the folder contents.
    let mut submodules = Vec::new();
    for entry in fs::read_dir(directory.as_ref())? {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() && path.file_name().unwrap() != "mod.rs" {
            let file_stem = path
                .file_stem()
                .and_then(|f| f.to_str())
                .expect("Could not get file name")
                .to_owned();

            submodules.push(file_stem);
        }
    }

    submodules.sort();

    let contents = submodules.iter().map(|f| format!("pub mod {f};\n"));
    let contents = std::iter::once(
        "#![allow(clippy::pedantic, reason = \"generated by build.rs and tonic\")]\n".to_string(),
    )
    .chain(std::iter::once(
        "#![allow(clippy::large_enum_variant, reason = \"generated by build.rs and tonic\")]\n\n"
            .to_string(),
    ))
    .chain(contents)
    .collect::<String>();

    fs::write(mod_filepath, contents)
}
